<?xml version="1.0" encoding="UTF-8"?>
<chat_system_framework_specification>

    <project_metadata>
        <typescript_standards_compliance>ts_readme.xml</typescript_standards_compliance>
        <testing_framework>jest</testing_framework>
        <minimum_coverage>80%</minimum_coverage>
        <utility_coverage>100%</utility_coverage>
        <requirements_source>User clarification: double-click shows full thread, single panel, no limits, no persistence</requirements_source>
    </project_metadata>

    <system_overview>
        <description>
            Advanced chat system for node-based conversation editor with complete thread visualization.
            Double-clicking any node opens a chat interface showing the entire conversation path from root to selected node.
            Users can add new content via /prompt (creates child nodes with LLM responses) or /md (adds markdown to previous prompt node).
            All changes synchronize bidirectionally between chat interface and graph visualization.
        </description>

        <core_behavior_specification>
            <double_click_activation>
                <trigger>Double-click on any node in the graph</trigger>
                <response>Open chat panel showing complete conversation thread from root node to clicked node</response>
                <thread_construction>Traverse from clicked node up to root, then display messages in chronological order</thread_construction>
                <entry_point>Chat input allows /prompt or /md commands to continue conversation</entry_point>
            </double_click_activation>

            <conversation_flow_rules>
                <prompt_command>
                    <input>/prompt [content]</input>
                    <behavior>Creates new child node from current deepest node in thread</behavior>
                    <llm_integration>Sends prompt to Gemini API for response generation</llm_integration>
                    <node_creation>New child contains both user prompt block and LLM response block</node_creation>
                    <thread_update>Chat interface updates to show new exchange</thread_update>
                    <graph_update>Graph editor renders new child node with connection</graph_update>
                </prompt_command>

                <markdown_command>
                    <input>/md [content]</input>
                    <behavior>Adds markdown block to the most recent prompt node (not response node)</behavior>
                    <association_rule>Markdown blocks associate with previous prompt that generated a response</association_rule>
                    <node_update>Existing prompt node gains additional markdown block</node_update>
                    <visual_update>Both chat interface and graph node update to show new content</visual_update>
                </markdown_command>

                <thread_association_examples>
                    <scenario_1>
                        <sequence>prompt1 → response1 → md1 → md2 → prompt2 → response2 → md3</sequence>
                        <node_structure>
                            <node1>prompt1, response1, md1, md2</node1>
                            <node2_child_of_node1>prompt2, response2, md3</node2_child_of_node1>
                        </node_structure>
                    </scenario_1>

                    <scenario_2>
                        <sequence>prompt1 → response1 → prompt2 → response2 → md1 → md2</sequence>
                        <node_structure>
                            <node1>prompt1, response1</node1>
                            <node2_child_of_node1>prompt2, response2, md1, md2</node2_child_of_node1>
                        </node_structure>
                    </node_2>
                </thread_association_examples>
            </conversation_flow_rules>

            <ui_requirements>
                <single_panel>Only one chat panel open at any time</single_panel>
                <no_persistence>Panel state not saved across browser sessions</no_persistence>
                <no_conversation_limits>Unlimited messages and conversation length</no_conversation_limits>
                <full_thread_display>Always show complete conversation from root to current node</full_thread_display>
            </ui_requirements>
        </core_behavior_specification>
    </system_overview>

    <architecture_framework>
        <component_hierarchy>
            <chat_interface_layer>
                <component>ChatInterface</component>
                <responsibility>UI management, event handling, panel lifecycle</responsibility>
                <integration_points>
                    <point>GraphEditor double-click event subscription</point>
                    <point>Canvas layout adjustment coordination</point>
                    <point>Panel show/hide state management</point>
                </integration_points>
            </chat_interface_layer>

            <conversation_management_layer>
                <component>ConversationManager</component>
                <responsibility>Thread construction, node association logic, conversation flow</responsibility>
                <core_algorithms>
                    <algorithm>buildThreadFromNodeToRoot(nodeId): ConversationThread</algorithm>
                    <algorithm>associateMarkdownWithPreviousPrompt(markdownContent): void</algorithm>
                    <algorithm>createChildNodeForPromptResponse(promptContent): Promise<string></algorithm>
                </core_algorithms>
            </conversation_management_layer>

            <input_processing_layer>
                <component>ChatInputHandler</component>
                <responsibility>Command parsing, validation, input sanitization</responsibility>
                <command_grammar>
                    <grammar>/prompt WHITESPACE+ content</grammar>
                    <grammar>/md WHITESPACE+ content</grammar>
                    <grammar>content: any_text_without_leading_slash</grammar>
                </command_grammar>
            </input_processing_layer>

            <graph_synchronization_layer>
                <component>GraphSynchronizer</component>
                <responsibility>Bidirectional sync between chat state and graph nodes</responsibility>
                <sync_operations>
                    <operation>chat_to_graph: Update node blocks when chat messages added</operation>
                    <operation>graph_to_chat: Update chat display when nodes modified externally</operation>
                    <operation>structure_sync: Maintain thread integrity during graph changes</operation>
                </sync_operations>
            </graph_synchronization_layer>
        </component_hierarchy>

        <data_flow_specification>
            <double_click_flow>
                <step1>User double-clicks node → GraphEditor emits nodeDoubleClick event</step1>
                <step2>ChatInterface receives event → calls ConversationManager.buildThreadFromNodeToRoot()</step2>
                <step3>ConversationManager traverses parent chain → constructs ordered message list</step3>
                <step4>ChatInterface renders complete thread → shows panel</step4>
                <step5>Canvas adjusts to 60% width → chat panel occupies 40%</step5>
            </double_click_flow>

            <prompt_command_flow>
                <step1>User types "/prompt content" → ChatInputHandler validates command</step1>
                <step2>ChatInterface calls ConversationManager.createChildNodeForPromptResponse()</step2>
                <step3>ConversationManager creates child node → adds prompt block</step3>
                <step4>ConversationManager calls GeminiService.generateResponse()</step4>
                <step5>Streaming response creates response block in same child node</step5>
                <step6>GraphSynchronizer updates graph display → renders new child node</step6>
                <step7>ChatInterface refreshes thread display → shows new exchange</step7>
            </prompt_command_flow>

            <markdown_command_flow>
                <step1>User types "/md content" → ChatInputHandler validates command</step1>
                <step2>ConversationManager identifies previous prompt node in thread</step2>
                <step3>ConversationManager adds markdown block to identified node</step3>
                <step4>GraphSynchronizer updates node display → shows additional block</step4>
                <step5>ChatInterface refreshes thread display → shows markdown in context</step5>
            </markdown_command_flow>
        </data_flow_specification>

        <state_management_framework>
            <chat_interface_state>
                <current_thread>Complete conversation thread being displayed</current_thread>
                <active_node_id>Node that was double-clicked to open chat</active_node_id>
                <input_mode>Current command being typed (prompt/md/idle)</input_mode>
                <panel_visibility>Boolean panel display state</panel_visibility>
                <loading_states>Async operation status tracking</loading_states>
            </chat_interface_state>

            <conversation_state>
                <thread_nodes>Ordered list of node IDs from root to current</thread_nodes>
                <message_mapping>Map of node IDs to their contained messages</message_mapping>
                <last_prompt_node>Reference to most recent node containing prompt for markdown association</last_prompt_node>
                <conversation_depth>Current depth of conversation thread</conversation_depth>
            </conversation_state>

            <synchronization_state>
                <pending_updates>Queue of changes waiting to be applied to graph</pending_updates>
                <sync_lock>Prevents concurrent modifications during sync operations</sync_lock>
                <change_tracking>Monitor external graph changes that affect active conversation</change_tracking>
            </synchronization_state>
        </state_management_framework>
    </architecture_framework>

    <type_system_specification>
        <core_chat_types>
            <file_path>src/types/chat.types.ts</file_path>
            <type_definitions>
                <chat_message_type>
                    <name>ChatMessage</name>
                    <properties>
                        <property name="id" type="string" readonly="true">Unique message identifier</property>
                        <property name="type" type="ChatMessageType" readonly="true">Message classification</property>
                        <property name="content" type="string">Message text content</property>
                        <property name="timestamp" type="Date" readonly="true">Creation timestamp</property>
                        <property name="nodeId" type="string" readonly="true">Associated graph node</property>
                        <property name="blockId" type="string" readonly="true">Associated node block</property>
                    </properties>
                </chat_message_type>

                <chat_message_type_enum>
                    <name>ChatMessageType</name>
                    <values>
                        <value>user_prompt</value>
                        <value>assistant_response</value>
                        <value>user_markdown</value>
                    </values>
                </chat_message_type_enum>

                <conversation_thread_type>
                    <name>ConversationThread</name>
                    <properties>
                        <property name="id" type="string" readonly="true">Thread identifier</property>
                        <property name="rootNodeId" type="string" readonly="true">Starting node of conversation</property>
                        <property name="targetNodeId" type="string" readonly="true">Node that was double-clicked</property>
                        <property name="nodePath" type="string[]" readonly="true">Ordered node IDs from root to target</property>
                        <property name="messages" type="ChatMessage[]" readonly="true">All messages in chronological order</property>
                        <property name="depth" type="number" readonly="true">Thread depth (number of nodes)</property>
                    </properties>
                </conversation_thread_type>

                <chat_command_type>
                    <name>ChatCommand</name>
                    <union_values>/prompt | /md</union_values>
                </chat_command_type>

                <chat_command_result_type>
                    <name>ChatCommandResult</name>
                    <properties>
                        <property name="command" type="ChatCommand | null">Parsed command</property>
                        <property name="content" type="string">Content after command</property>
                        <property name="isValid" type="boolean">Validation result</property>
                        <property name="error" type="string | undefined">Error message if invalid</property>
                    </properties>
                </chat_command_result_type>
            </type_definitions>
        </core_chat_types>

        <conversation_management_types>
            <file_path>src/types/conversation.types.ts</file_path>
            <type_definitions>
                <node_association_rule_type>
                    <name>NodeAssociationRule</name>
                    <properties>
                        <property name="markdownTargetsLastPrompt" type="boolean">Markdown associates with previous prompt node</property>
                        <property name="promptCreatesNewChild" type="boolean">Prompts always create child nodes</property>
                        <property name="responseInSameNode" type="boolean">Responses go in same node as prompt</property>
                    </properties>
                </node_association_rule_type>

                <conversation_flow_state_type>
                    <name>ConversationFlowState</name>
                    <properties>
                        <property name="currentThreadId" type="string | null">Active conversation thread</property>
                        <property name="lastPromptNodeId" type="string | null">Most recent prompt node for markdown targeting</property>
                        <property name="associationRules" type="NodeAssociationRule">Rules for content association</property>
                        <property name="pendingOperations" type="PendingOperation[]">Queue of operations to apply</property>
                    </properties>
                </conversation_flow_state_type>

                <pending_operation_type>
                    <name>PendingOperation</name>
                    <discriminated_union>
                        <variant type="create_child">
                            <property name="type" type="create_child">Operation type</property>
                            <property name="parentNodeId" type="string">Parent node for new child</property>
                            <property name="promptContent" type="string">Prompt content for new node</property>
                        </variant>
                        <variant type="add_markdown">
                            <property name="type" type="add_markdown">Operation type</property>
                            <property name="targetNodeId" type="string">Node to add markdown to</property>
                            <property name="markdownContent" type="string">Markdown content to add</property>
                        </variant>
                        <variant type="add_response">
                            <property name="type" type="add_response">Operation type</property>
                            <property name="targetNodeId" type="string">Node to add response to</property>
                            <property name="responseContent" type="string">Response content to add</property>
                        </variant>
                    </discriminated_union>
                </pending_operation_type>
            </type_definitions>
        </conversation_management_types>

        <ui_state_types>
            <file_path>src/types/chat-ui.types.ts</file_path>
            <type_definitions>
                <chat_interface_state_type>
                    <name>ChatInterfaceState</name>
                    <properties>
                        <property name="activeThread" type="ConversationThread | null">Currently displayed thread</property>
                        <property name="isVisible" type="boolean">Panel visibility state</property>
                        <property name="panelWidth" type="number">Panel width percentage (30-70)</property>
                        <property name="inputMode" type="InputMode">Current input state</property>
                        <property name="inputContent" type="string">Current input field content</property>
                        <property name="loadingStates" type="LoadingStates">Async operation tracking</property>
                    </properties>
                </chat_interface_state_type>

                <input_mode_type>
                    <name>InputMode</name>
                    <union_values>idle | typing_prompt | typing_markdown</union_values>
                </input_mode_type>

                <loading_states_type>
                    <name>LoadingStates</name>
                    <properties>
                        <property name="sendingMessage" type="boolean">Message send in progress</property>
                        <property name="generatingResponse" type="boolean">LLM response generation</property>
                        <property name="updatingGraph" type="boolean">Graph synchronization</property>
                        <property name="buildingThread" type="boolean">Thread construction</property>
                    </properties>
                </loading_states_type>
            </type_definitions>
        </ui_state_types>
    </type_system_specification>

    <component_interface_specifications>
        <chat_interface_component>
            <file_path>src/components/chat-interface.ts</file_path>
            <class_signature>
                export class ChatInterface {
                constructor(
                parentContainer: HTMLElement,
                graphEditor: GraphEditor,
                config?: Partial<ChatConfig>
                );
                }
            </class_signature>

            <public_api_methods>
                <method name="openChatForNode">
                    <signature>public async openChatForNode(nodeId: string): Promise<void></signature>
                    <description>Opens chat panel showing complete thread from root to specified node</description>
                    <parameters>
                        <parameter name="nodeId" type="string">Target node ID to open chat for</parameter>
                    </parameters>
                    <throws>ValidationError if nodeId doesn't exist</throws>
                    <side_effects>
                        <effect>Shows chat panel</effect>
                        <effect>Adjusts canvas layout to 60% width</effect>
                        <effect>Builds and displays conversation thread</effect>
                        <effect>Focuses input field</effect>
                    </side_effects>
                    <logging>
                        <log_entry>Function entry with nodeId</log_entry>
                        <log_exit>Function exit with performance metrics</log_exit>
                        <log_user_interaction>chat_opened event with node details</log_user_interaction>
                    </logging>
                </method>

                <method name="closeChat">
                    <signature>public closeChat(): void</signature>
                    <description>Closes chat panel and resets canvas layout</description>
                    <side_effects>
                        <effect>Hides chat panel</effect>
                        <effect>Resets canvas to full width</effect>
                        <effect>Clears chat state</effect>
                    </side_effects>
                    <logging>
                        <log_user_interaction>chat_closed event</log_user_interaction>
                    </logging>
                </method>

                <method name="isVisible">
                    <signature>public isVisible(): boolean</signature>
                    <description>Returns current panel visibility state</description>
                    <returns>Boolean indicating if panel is currently visible</returns>
                </method>

                <method name="getCurrentThread">
                    <signature>public getCurrentThread(): ConversationThread | null</signature>
                    <description>Returns currently displayed conversation thread</description>
                    <returns>Active thread or null if no chat open</returns>
                </method>
            </public_api_methods>

            <private_methods>
                <method name="createUIElements">
                    <responsibility>Construct DOM elements for chat panel</responsibility>
                    <creates>Panel container, header, messages area, input section, resize handle</creates>
                </method>

                <method name="setupEventListeners">
                    <responsibility>Bind user interaction handlers</responsibility>
                    <events>close button, input changes, send button, keyboard shortcuts, resize</events>
                </method>

                <method name="renderThread">
                    <responsibility>Display complete conversation thread in chronological order</responsibility>
                    <rendering_logic>Group messages by node, show timestamps, handle markdown rendering</rendering_logic>
                </method>

                <method name="handleInputCommand">
                    <responsibility>Process /prompt and /md commands</responsibility>
                    <validation>Command syntax, content length, current context</validation>
                </method>

                <method name="updateGraphSync">
                    <responsibility>Coordinate changes with graph editor</responsibility>
                    <sync_operations>Node creation, block addition, visual updates</sync_operations>
                </method>
            </private_methods>

            <event_handlers>
                <handler name="onNodeDoubleClick">
                    <trigger>GraphEditor nodeDoubleClick event</trigger>
                    <action>Call openChatForNode with clicked node ID</action>
                </handler>

                <handler name="onInputChange">
                    <trigger>Textarea input event</trigger>
                    <action>Parse command, validate, update UI state</action>
                </handler>

                <handler name="onSendMessage">
                    <trigger>Send button click or Ctrl+Enter</trigger>
                    <action>Process command, execute operation, update displays</action>
                </handler>

                <handler name="onClosePanel">
                    <trigger>Close button click or Escape key</trigger>
                    <action>Close chat panel and reset layout</action>
                </handler>
            </event_handlers>
        </chat_interface_component>

        <conversation_manager_service>
            <file_path>src/services/conversation-manager.ts</file_path>
            <class_signature>
                export class ConversationManager {
                constructor(graphEditor: GraphEditor);
                }
            </class_signature>

            <core_algorithms>
                <algorithm name="buildThreadFromNodeToRoot">
                    <signature>buildThreadFromNodeToRoot(nodeId: string): ConversationThread</signature>
                    <description>Constructs complete conversation thread from target node back to root</description>
                    <algorithm_steps>
                        <step1>Start with target node, traverse parentId chain to root</step1>
                        <step2>Reverse path to get root-to-target order</step2>
                        <step3>Extract all blocks from each node in order</step3>
                        <step4>Convert blocks to ChatMessage objects with proper typing</step4>
                        <step5>Return ConversationThread with complete message sequence</step5>
                    </algorithm_steps>
                    <complexity>O(depth) where depth is node distance from root</complexity>
                    <error_handling>Throws if nodeId doesn't exist or path is broken</error_handling>
                </algorithm>

                <algorithm name="createChildNodeForPrompt">
                    <signature>async createChildNodeForPrompt(parentNodeId: string, promptContent: string): Promise<string></signature>
                    <description>Creates new child node with prompt block and generates LLM response</description>
                    <algorithm_steps>
                        <step1>Validate parent node exists</step1>
                        <step2>Create new GraphNode as child of parent</step2>
                        <step3>Add prompt block with user content</step3>
                        <step4>Call GeminiService to generate response</step4>
                        <step5>Add response block with LLM content</step5>
                        <step6>Update graph editor display</step6>
                        <step7>Return new node ID</step7>
                    </algorithm_steps>
                    <llm_integration>Uses existing GeminiService with conversation context</llm_integration>
                    <error_handling>Rollback node creation if LLM call fails</error_handling>
                </algorithm>

                <algorithm name="associateMarkdownWithPreviousPrompt">
                    <signature>associateMarkdownWithPreviousPrompt(markdownContent: string, currentThread: ConversationThread): void</signature>
                    <description>Adds markdown block to the most recent prompt node in thread</description>
                    <algorithm_steps>
                        <step1>Traverse thread messages in reverse chronological order</step1>
                        <step2>Find most recent user_prompt message</step2>
                        <step3>Identify associated node from message.nodeId</step3>
                        <step4>Add new markdown block to that node</step4>
                        <step5>Update graph editor display for modified node</step5>
                    </algorithm_steps>
                    <edge_cases>
                        <case>No previous prompts: throw ValidationError</case>
                        <case>Previous prompt node deleted: find next available prompt node</case>
                    </edge_cases>
                </algorithm>
            </core_algorithms>

            <node_association_logic>
                <prompt_association>
                    <rule>New prompts always create child nodes</rule>
                    <rule>Prompt and response blocks go in same child node</rule>
                    <rule>Child node becomes new "current" node for subsequent markdown</rule>
                </prompt_association>

                <markdown_association>
                    <rule>Markdown blocks always associate with previous prompt node</rule>
                    <rule>Multiple consecutive markdown commands add to same prompt node</rule>
                    <rule>Markdown never creates new nodes, only adds blocks</rule>
                </markdown_association>

                <response_association>
                    <rule>LLM responses always go in same node as the triggering prompt</rule>
                    <rule>Responses are automatically generated, never user-created</rule>
                    <rule>One response block per prompt block in a node</rule>
                </response_association>
            </node_association_logic>
        </conversation_manager_service>

        <chat_input_handler_service>
            <file_path>src/services/chat-input-handler.ts</file_path>
            <class_signature>
                export class ChatInputHandler {
                constructor();
                }
            </class_signature>

            <command_parsing_specification>
                <grammar_definition>
                    <command_syntax>/prompt WHITESPACE+ content</command_syntax>
                    <command_syntax>/md WHITESPACE+ content</command_syntax>
                    <whitespace>One or more spaces or tabs</whitespace>
                    <content>Any text not starting with forward slash</content>
                </grammar_definition>

                <parsing_algorithm>
                    <method name="parseCommand">
                        <signature>parseCommand(input: string): ChatCommandResult</signature>
                        <parsing_steps>
                            <step1>Trim input and check for empty string</step1>
                            <step2>Check if input starts with forward slash</step2>
                            <step3>Extract command word (up to first whitespace)</step3>
                            <step4>Validate command against allowed list [/prompt, /md]</step4>
                            <step5>Extract content (everything after first whitespace)</step5>
                            <step6>Validate content requirements for specific commands</step6>
                            <step7>Return ChatCommandResult with validation status</step7>
                        </parsing_steps>
                        <validation_rules>
                            <rule>/prompt requires non-empty content</rule>
                            <rule>/md requires non-empty content</rule>
                            <rule>Content cannot start with forward slash</rule>
                            <rule>Maximum content length: 10,000 characters</rule>
                        </validation_rules>
                    </method>
                </parsing_algorithm>

                <input_sanitization>
                    <html_escaping>Escape HTML entities to prevent XSS</html_escaping>
                    <whitespace_normalization>Normalize line endings and excess whitespace</whitespace_normalization>
                    <length_limits>Enforce maximum input length per command type</length_limits>
                    <rate_limiting>Prevent rapid command submission</rate_limiting>
                </input_sanitization>

                <error_handling>
                    <unknown_command>Return error message listing valid commands</unknown_command>
                    <empty_content>Return specific error for command that requires content</empty_content>
                    <malformed_input>Return general parsing error with helpful hints</malformed_input>
                </error_handling>
            </command_parsing_specification>
        </chat_input_handler_service>

        <graph_synchronizer_service>
            <file_path>src/services/graph-synchronizer.ts</file_path>
            <class_signature>
                export class GraphSynchronizer {
                constructor(graphEditor: GraphEditor, chatInterface: ChatInterface);
                }
            </class_signature>

            <synchronization_responsibilities>
                <chat_to_graph_sync>
                    <operation name="syncNewChildNode">
                        <description>Update graph display when chat creates new child node</description>
                        <triggers>ConversationManager.createChildNodeForPrompt completion</triggers>
                        <actions>Call GraphEditor.renderNode, update connections, run auto-layout if needed</actions>
                    </operation>

                    <operation name="syncNodeBlockAddition">
                        <description>Update node display when markdown block added</description>
                        <triggers>ConversationManager.associateMarkdownWithPreviousPrompt completion</triggers>
                        <actions>Call GraphEditor.renderNode for modified node</actions>
                    </operation>

                    <operation name="syncResponseBlock">
                        <description>Update node display during streaming LLM response</description>
                        <triggers>GeminiService streaming response chunks</triggers>
                        <actions>Update node block content in real-time</actions>
                    </operation>
                </chat_to_graph_sync>

                <graph_to_chat_sync>
                    <operation name="handleNodeDeletion">
                        <description>Update chat thread when node deleted externally</description>
                        <triggers>GraphEditor node deletion events</triggers>
                        <actions>Rebuild thread, update chat display, handle broken references</actions>
                    </operation>

                    <operation name="handleNodeModification">
                        <description>Update chat display when node content changed externally</description>
                        <triggers>GraphEditor node content change events</triggers>
                        <actions>Refresh message content in chat interface</actions>
                    </operation>

                    <operation name="handleStructureChange">
                        <description>Update chat thread when graph structure changes</description>
                        <triggers>GraphEditor tree structure modification events</triggers>
                        <actions>Validate thread integrity, rebuild if necessary</actions>
                    </operation>
                </graph_to_chat_sync>
            </synchronization_responsibilities>

            <conflict_resolution>
                <concurrent_modifications>
                    <strategy>Use operation queuing to serialize conflicting changes</strategy>
                    <priority>Chat-initiated changes take precedence over external graph changes</priority>
                    <rollback>Implement rollback for failed synchronization operations</rollback>
                </concurrent_modifications>

                <data_consistency>
                    <validation>Verify node/block relationships after each sync operation</validation>
                    <repair>Automatic repair of minor inconsistencies</repair>
                    <escalation>Report irrecoverable conflicts to error handling system</escalation>
                </data_consistency>
            </conflict_resolution>
        </graph_synchronizer_service>
    </component_interface_specifications>

    <integration_specification>
        <graph_editor_integration>
            <double_click_event_binding>
                <location>src/components/graph-editor.ts setupEventListeners method</location>
                <implementation_approach>
                    <step1>Add event delegation for double-click events on .node elements</step1>
                    <step2>Extract nodeId from clicked element's data attributes</step2>
                    <step3>Call ChatInterface.openChatForNode(nodeId)</step3>
                    <step4>Prevent default double-click behavior (text selection)</step4>
                </implementation_approach>
                <event_handler_code_structure>
                    // In GraphEditor.setupEventListeners()
                    this.canvasContent.addEventListener('dblclick', (e: MouseEvent) => {
                    const nodeElement = (e.target as Element).closest('.node');
                    if (nodeElement && nodeElement.hasAttribute('data-node-id')) {
                    const nodeId = nodeElement.getAttribute('data-node-id');
                    this.chatInterface.openChatForNode(nodeId);
                    }
                    });
                </event_handler_code_structure>
            </double_click_event_binding>

            <canvas_layout_coordination>
                <canvas_width_adjustment>
                    <default_state>Canvas uses full container width when chat closed</default_state>
                    <chat_open_state>Canvas width reduces to 60% when chat panel visible</chat_open_state>
                    <transition>Smooth CSS transition for width changes</transition>
                    <responsive_behavior>Chat panel hides on mobile, canvas returns to full width</responsive_behavior>
                </canvas_width_adjustment>

                <css_modifications>
                    <canvas_container_styles>
                        .canvas-container {
                        width: 100%;
                        transition: width 0.3s ease;
                        }

                        .canvas-container.chat-active {
                        width: 60%;
                        }
                    </canvas_container_styles>
                </css_modifications>
            </canvas_layout_coordination>

            <node_lifecycle_integration>
                <node_creation_events>
                    <source>ChatInterface creates nodes via ConversationManager</source>
                    <notification>GraphEditor receives notification to render new nodes</notification>
                    <auto_layout>Trigger auto-layout after node creation to maintain tree structure</auto_layout>
                </node_creation_events>

                <node_modification_events>
                    <source>ChatInterface modifies node blocks via ConversationManager</source>
                    <notification>GraphEditor receives notification to re-render modified nodes</notification>
                    <visual_feedback>Highlight modified nodes temporarily to show updates</visual_feedback>
                </node_modification_events>
            </node_lifecycle_integration>
        </graph_editor_integration>

        <gemini_service_integration>
            <conversation_context_enhancement>
                <context_building>Include relevant conversation history in LLM prompts</context_building>
                <context_window_management>Intelligently truncate long conversations to fit token limits</context_window_management>
                <context_preservation>Maintain important context elements across truncation</context_preservation>
            </conversation_context_enhancement>

            <streaming_response_handling>
                <real_time_display>Update chat interface as response streams in</real_time_display>
                <node_sync>Update graph node blocks in real-time during streaming</node_sync>
                <error_recovery>Handle streaming interruptions and partial responses</error_recovery>
                <completion_callback>Finalize response and update all displays when streaming completes</completion_callback>
            </streaming_response_handling>

            <enhanced_service_interface>
                <method name="generateChatResponse">
                    <signature>generateChatResponse(prompt: string, conversationHistory: ChatMessage[]): AsyncIterable<string></signature>
                    <description>Generate streaming response with conversation context</description>
                    <context_handling>Build appropriate context from conversation history</context_handling>
                    <streaming>Yield response chunks for real-time display</streaming>
                </method>
            </enhanced_service_interface>
        </gemini_service_integration>

        <ui_framework_integration>
            <css_architecture>
                <base_styles>Extend existing CSS with chat-specific styles</base_styles>
                <theme_consistency>Match existing color scheme and typography</theme_consistency>
                <responsive_design>Ensure chat interface works across device sizes</responsive_design>
            </css_architecture>

            <accessibility_integration>
                <keyboard_navigation>Full keyboard access for all chat functions</keyboard_navigation>
                <screen_reader_support>Proper ARIA labels and semantic markup</screen_reader_support>
                <focus_management>Logical focus order and clear visual indicators</focus_management>
            </accessibility_integration>

            <performance_integration>
                <virtual_scrolling>Implement for very long conversations</virtual_scrolling>
                <lazy_loading>Load conversation history on demand</lazy_loading>
                <memory_management>Efficient cleanup of DOM elements and event listeners</memory_management>
            </performance_integration>
        </ui_framework_integration>
    </integration_specification>

    <testing_framework_specification>
        <test_architecture>
            <unit_test_organization>
                <chat_interface_tests>
                    <file>tests/components/chat-interface.test.ts</file>
                    <coverage_target>90%</coverage_target>
                    <test_suites>
                        <suite>Component initialization and DOM creation</suite>
                        <suite>Event handling and user interactions</suite>
                        <suite>Thread rendering and display</suite>
                        <suite>Command processing and validation</suite>
                        <suite>Error handling and edge cases</suite>
                    </test_suites>
                </chat_interface_tests>

                <conversation_manager_tests>
                    <file>tests/services/conversation-manager.test.ts</file>
                    <coverage_target>95%</coverage_target>
                    <test_suites>
                        <suite>Thread construction algorithms</suite>
                        <suite>Node association logic</suite>
                        <suite>LLM integration handling</suite>
                        <suite>Graph synchronization</suite>
                    </test_suites>
                </conversation_manager_tests>

                <input_handler_tests>
                    <file>tests/services/chat-input-handler.test.ts</file>
                    <coverage_target>100%</coverage_target>
                    <test_suites>
                        <suite>Command parsing accuracy</suite>
                        <suite>Input validation rules</suite>
                        <suite>Security sanitization</suite>
                        <suite>Error message clarity</suite>
                    </test_suites>
                </input_handler_tests>
            </unit_test_organization>

            <integration_test_scenarios>
                <end_to_end_conversation_flow>
                    <test_file>tests/integration/complete-conversation.test.ts</test_file>
                    <scenario_steps>
                        <step1>Double-click node to open chat</step1>
                        <step2>Send /prompt command</step2>
                        <step3>Verify child node creation</step3>
                        <step4>Verify LLM response generation</step4>
                        <step5>Send /md command</step5>
                        <step6>Verify markdown association with prompt node</step6>
                        <step7>Verify graph display updates</step7>
                        <step8>Close chat and verify cleanup</step8>
                    </scenario_steps>
                </end_to_end_conversation_flow>

                <complex_thread_construction>
                    <test_file>tests/integration/thread-building.test.ts</test_file>
                    <scenario_description>Test thread construction for deeply nested conversations</scenario_description>
                    <test_data>Create conversation tree 10 levels deep with mixed prompt/markdown blocks</test_data>
                    <validation>Verify correct chronological ordering and node associations</validation>
                </complex_thread_construction>

                <graph_synchronization_integrity>
                    <test_file>tests/integration/graph-sync.test.ts</test_file>
                    <scenario_description>Test bidirectional synchronization between chat and graph</scenario_description>
                    <test_cases>
                        <case>External node deletion while chat open</case>
                        <case>External node modification during conversation</case>
                        <case>Concurrent chat operations and graph changes</case>
                    </test_cases>
                </graph_synchronization_integrity>
            </integration_test_scenarios>

            <mock_specifications>
                <gemini_service_mock>
                    <purpose>Mock LLM responses for deterministic testing</purpose>
                    <capabilities>
                        <capability>Configurable response content</capability>
                        <capability>Simulated streaming behavior</capability>
                        <capability>Error condition simulation</capability>
                        <capability>Latency simulation</capability>
                    </capabilities>
                </gemini_service_mock>

                <graph_editor_mock>
                    <purpose>Mock graph editor for isolated chat testing</purpose>
                    <capabilities>
                        <capability>Node CRUD operations</capability>
                        <capability>Event emission simulation</capability>
                        <capability>State inspection methods</capability>
                        <capability>Layout calculation mocking</capability>
                    </capabilities>
                </graph_editor_mock>

                <dom_environment_mock>
                    <purpose>Mock DOM APIs for headless testing</purpose>
                    <setup>Use jsdom with custom event handling</setup>
                    <coverage>All DOM manipulation and event handling code</coverage>
                </dom_environment_mock>
            </mock_specifications>
        </test_architecture>

        <test_data_management>
            <conversation_fixtures>
                <simple_thread>Root → Child1 (prompt/response) → Child2 (prompt/response)</simple_thread>
                <complex_thread>Root → Child1 (prompt/response/md/md) → Child2 (prompt/response) → Child3 (prompt/response/md)</complex_thread>
                <deep_thread>Linear conversation 15 nodes deep for performance testing</deep_thread>
            </conversation_fixtures>

            <command_test_cases>
                <valid_commands>
                    <case>/prompt Hello, how are you?</case>
                    <case>/md # This is a markdown header</case>
                    <case>/prompt   Extra spaces should work   </case>
                </valid_commands>

                <invalid_commands>
                    <case>/unknown command</case>
                    <case>/prompt</case>
                    <case>/md</case>
                    <case>No leading slash</case>
                </invalid_commands>
            </command_test_cases>

            <error_condition_simulations>
                <network_errors>Simulate Gemini API failures during response generation</network_errors>
                <dom_errors>Simulate DOM manipulation failures</dom_errors>
                <validation_errors>Test all input validation edge cases</validation_errors>
                <concurrency_errors>Simulate race conditions in async operations</concurrency_errors>
            </error_condition_simulations>
        </test_data_management>
    </testing_framework_specification>

    <implementation_phases>
        <phase_1_foundation>
            <deliverables>
                <deliverable>Type system implementation (chat.types.ts, conversation.types.ts)</deliverable>
                <deliverable>ChatInputHandler service with command parsing</deliverable>
                <deliverable>Basic ChatInterface component with UI structure</deliverable>
                <deliverable>Double-click integration with GraphEditor</deliverable>
                <deliverable>Unit tests for core parsing and validation logic</deliverable>
            </deliverables>
            <acceptance_criteria>
                <criterion>Double-clicking any node opens chat panel</criterion>
                <criterion>Chat panel shows placeholder for thread content</criterion>
                <criterion>Command parsing works correctly for /prompt and /md</criterion>
                <criterion>Panel can be opened and closed properly</criterion>
                <criterion>Canvas layout adjusts when chat opens</criterion>
            </acceptance_criteria>
        </phase_1_foundation>

        <phase_2_conversation_logic>
            <deliverables>
                <deliverable>ConversationManager service with thread building algorithms</deliverable>
                <deliverable>Node association logic for prompts and markdown</deliverable>
                <deliverable>GraphSynchronizer service for bidirectional sync</deliverable>
                <deliverable>Integration with existing GeminiService</deliverable>
                <deliverable>Complete conversation flow implementation</deliverable>
            </deliverables>
            <acceptance_criteria>
                <criterion>Thread construction works correctly for any node depth</criterion>
                <criterion>/prompt commands create child nodes with LLM responses</criterion>
                <criterion>/md commands add blocks to correct prompt nodes</criterion>
                <criterion>Graph display updates synchronously with chat operations</criterion>
                <criterion>Streaming responses work in both chat and graph views</criterion>
            </acceptance_criteria>
        </phase_2_conversation_logic>

        <phase_3_ui_polish>
            <deliverables>
                <deliverable>Complete UI styling with LibreChat inspiration</deliverable>
                <deliverable>Message rendering with proper formatting</deliverable>
                <deliverable>Loading states and error handling UI</deliverable>
                <deliverable>Keyboard shortcuts and accessibility features</deliverable>
                <deliverable>Panel resizing functionality</deliverable>
            </deliverables>
            <acceptance_criteria>
                <criterion>Chat interface matches design specifications</criterion>
                <criterion>Messages display correctly with timestamps and formatting</criterion>
                <criterion>Loading states provide clear feedback to users</criterion>
                <criterion>Interface is fully keyboard accessible</criterion>
                <criterion>Error messages are clear and actionable</criterion>
            </acceptance_criteria>
        </phase_3_ui_polish>

        <phase_4_testing_and_optimization>
            <deliverables>
                <deliverable>Comprehensive test suite with 80%+ coverage</deliverable>
                <deliverable>Integration tests for complex conversation flows</deliverable>
                <deliverable>Performance optimization for large conversations</deliverable>
                <deliverable>Error handling improvements and edge case coverage</deliverable>
                <deliverable>Documentation updates and code cleanup</deliverable>
            </deliverables>
            <acceptance_criteria>
                <criterion>All tests pass with required coverage levels</criterion>
                <criterion>Performance is acceptable for conversations with 100+ exchanges</criterion>
                <criterion>Error conditions are handled gracefully</criterion>
                <criterion>Code follows all ts_readme.xml standards</criterion>
                <criterion>Documentation accurately reflects implementation</criterion>
            </acceptance_criteria>
        </phase_4_testing_and_optimization>
    </implementation_phases>

    <quality_assurance_framework>
        <code_review_requirements>
            <typescript_compliance>
                <requirement>All functions have explicit return types</requirement>
                <requirement>No any types without TSDoc justification</requirement>
                <requirement>Proper error handling with custom error types</requirement>
                <requirement>Runtime type validation for all external inputs</requirement>
                <requirement>Branded types for domain-specific values</requirement>
            </typescript_compliance>

            <architecture_compliance>
                <requirement>Single responsibility principle for all classes</requirement>
                <requirement>Dependency injection for service dependencies</requirement>
                <requirement>Event-driven communication between components</requirement>
                <requirement>Proper separation of UI, business logic, and data layers</requirement>
                <requirement>Consistent error handling patterns throughout</requirement>
            </architecture_compliance>

            <performance_requirements>
                <requirement>Chat panel opens in under 200ms for typical conversations</requirement>
                <requirement>Command processing completes in under 100ms</requirement>
                <requirement>Memory usage stays constant for conversations under 1000 messages</requirement>
                <requirement>No memory leaks in event listener management</requirement>
                <requirement>Smooth 60fps animations for all UI transitions</requirement>
            </performance_requirements>

            <security_requirements>
                <requirement>All user input sanitized against XSS attacks</requirement>
                <requirement>Command injection prevention in chat commands</requirement>
                <requirement>Rate limiting on user actions to prevent abuse</requirement>
                <requirement>No sensitive data logged in any logging statements</requirement>
                <requirement>Secure handling of LLM responses and conversation data</requirement>
            </security_requirements>
        </code_review_requirements>

        <testing_standards>
            <coverage_requirements>
                <minimum_line_coverage>80%</minimum_line_coverage>
                <minimum_branch_coverage>80%</minimum_branch_coverage>
                <minimum_function_coverage>90%</minimum_function_coverage>
                <utility_function_coverage>100%</utility_function_coverage>
            </coverage_requirements>

            <test_quality_standards>
                <requirement>Descriptive test names that explain the scenario</requirement>
                <requirement>Arrange-Act-Assert pattern for all tests</requirement>
                <requirement>Proper mocking of external dependencies</requirement>
                <requirement>Test isolation with no shared state between tests</requirement>
                <requirement>Edge case coverage for all public APIs</requirement>
            </test_quality_standards>

            <integration_test_standards>
                <requirement>End-to-end scenarios for all major user workflows</requirement>
                <requirement>Error condition testing for all async operations</requirement>
                <requirement>Performance validation for large data sets</requirement>
                <requirement>Cross-browser compatibility verification</requirement>
                <requirement>Accessibility compliance validation</requirement>
            </integration_test_standards>
        </testing_standards>

    </quality_assurance_framework>

</chat_system_framework_specification>